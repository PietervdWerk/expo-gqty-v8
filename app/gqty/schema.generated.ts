/**
 * GQty AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */

import { SchemaUnionsKey } from "gqty";

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  Decimal: any;
  /** The builtin Time type */
  Time: any;
}

/**
 * CreateRecipeAuthorInput is used for create RecipeAuthor object.
 * Input was generated by ent.
 */
export interface CreateRecipeAuthorInput {
  name: Scalars["String"];
  recipeIDs?: InputMaybe<Array<Scalars["ID"]>>;
}

/**
 * CreateRecipeIngredientInput is used for create RecipeIngredient object.
 * Input was generated by ent.
 */
export interface CreateRecipeIngredientInput {
  recipeIDs?: InputMaybe<Array<Scalars["ID"]>>;
}

/**
 * CreateRecipeInput is used for create Recipe object.
 * Input was generated by ent.
 */
export interface CreateRecipeInput {
  authorIDs?: InputMaybe<Array<Scalars["ID"]>>;
  cookTime: Scalars["Int"];
  description: Scalars["String"];
  ingredientIDs?: InputMaybe<Array<Scalars["ID"]>>;
  instructionIDs?: InputMaybe<Array<Scalars["ID"]>>;
  name: Scalars["String"];
  prepTime: Scalars["Int"];
  yield: Scalars["Int"];
  yieldUnit: RecipeYieldUnit;
}

/**
 * CreateRecipeInstructionInput is used for create RecipeInstruction object.
 * Input was generated by ent.
 */
export interface CreateRecipeInstructionInput {
  instruction: Scalars["String"];
  recipeID?: InputMaybe<Scalars["ID"]>;
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  ASC = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  DESC = "DESC",
}

/** ProductActionAction is enum for the field action */
export enum ProductActionAction {
  price_increase = "price_increase",
  price_reduction = "price_reduction",
}

/**
 * ProductActionWhereInput is used for filtering ProductAction objects.
 * Input was generated by ent.
 */
export interface ProductActionWhereInput {
  /** action field predicates */
  action?: InputMaybe<ProductActionAction>;
  actionIn?: InputMaybe<Array<ProductActionAction>>;
  actionNEQ?: InputMaybe<ProductActionAction>;
  actionNotIn?: InputMaybe<Array<ProductActionAction>>;
  and?: InputMaybe<Array<ProductActionWhereInput>>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars["Boolean"]>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** new_price field predicates */
  newPrice?: InputMaybe<Scalars["Decimal"]>;
  newPriceGT?: InputMaybe<Scalars["Decimal"]>;
  newPriceGTE?: InputMaybe<Scalars["Decimal"]>;
  newPriceIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  newPriceLT?: InputMaybe<Scalars["Decimal"]>;
  newPriceLTE?: InputMaybe<Scalars["Decimal"]>;
  newPriceNEQ?: InputMaybe<Scalars["Decimal"]>;
  newPriceNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  not?: InputMaybe<ProductActionWhereInput>;
  or?: InputMaybe<Array<ProductActionWhereInput>>;
}

/** ProductDefaultUnitType is enum for the field default_unit_type */
export enum ProductDefaultUnitType {
  kg = "kg",
  l = "l",
  none = "none",
  per = "per",
  stuk = "stuk",
}

/** ProductSaleDefaultUnitType is enum for the field default_unit_type */
export enum ProductSaleDefaultUnitType {
  kg = "kg",
  l = "l",
  none = "none",
  per = "per",
  stuk = "stuk",
}

/** ProductSaleType is enum for the field type */
export enum ProductSaleType {
  bulk_discount = "bulk_discount",
  discount = "discount",
  temporary_product = "temporary_product",
  while_stock_lasts = "while_stock_lasts",
  x_plus_y_free = "x_plus_y_free",
}

/** ProductSaleUnitType is enum for the field unit_type */
export enum ProductSaleUnitType {
  g = "g",
  kg = "kg",
  l = "l",
  ml = "ml",
  none = "none",
  pak = "pak",
  per = "per",
  pods = "pods",
  stuk = "stuk",
  stuks = "stuks",
  zakjes = "zakjes",
}

/**
 * ProductSaleWhereInput is used for filtering ProductSale objects.
 * Input was generated by ent.
 */
export interface ProductSaleWhereInput {
  and?: InputMaybe<Array<ProductSaleWhereInput>>;
  /** default_unit_type field predicates */
  defaultUnitType?: InputMaybe<ProductSaleDefaultUnitType>;
  defaultUnitTypeIn?: InputMaybe<Array<ProductSaleDefaultUnitType>>;
  defaultUnitTypeNEQ?: InputMaybe<ProductSaleDefaultUnitType>;
  defaultUnitTypeNotIn?: InputMaybe<Array<ProductSaleDefaultUnitType>>;
  /** default_unit_type_price field predicates */
  defaultUnitTypePrice?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceGT?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceGTE?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  defaultUnitTypePriceLT?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceLTE?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceNEQ?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** end field predicates */
  end?: InputMaybe<Scalars["Time"]>;
  endGT?: InputMaybe<Scalars["Time"]>;
  endGTE?: InputMaybe<Scalars["Time"]>;
  endIn?: InputMaybe<Array<Scalars["Time"]>>;
  endLT?: InputMaybe<Scalars["Time"]>;
  endLTE?: InputMaybe<Scalars["Time"]>;
  endNEQ?: InputMaybe<Scalars["Time"]>;
  endNotIn?: InputMaybe<Array<Scalars["Time"]>>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars["String"]>;
  externalIDContains?: InputMaybe<Scalars["String"]>;
  externalIDContainsFold?: InputMaybe<Scalars["String"]>;
  externalIDEqualFold?: InputMaybe<Scalars["String"]>;
  externalIDGT?: InputMaybe<Scalars["String"]>;
  externalIDGTE?: InputMaybe<Scalars["String"]>;
  externalIDHasPrefix?: InputMaybe<Scalars["String"]>;
  externalIDHasSuffix?: InputMaybe<Scalars["String"]>;
  externalIDIn?: InputMaybe<Array<Scalars["String"]>>;
  externalIDLT?: InputMaybe<Scalars["String"]>;
  externalIDLTE?: InputMaybe<Scalars["String"]>;
  externalIDNEQ?: InputMaybe<Scalars["String"]>;
  externalIDNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars["Boolean"]>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<ProductSaleWhereInput>;
  or?: InputMaybe<Array<ProductSaleWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars["Decimal"]>;
  priceGT?: InputMaybe<Scalars["Decimal"]>;
  priceGTE?: InputMaybe<Scalars["Decimal"]>;
  priceIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  priceLT?: InputMaybe<Scalars["Decimal"]>;
  priceLTE?: InputMaybe<Scalars["Decimal"]>;
  priceNEQ?: InputMaybe<Scalars["Decimal"]>;
  priceNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** start field predicates */
  start?: InputMaybe<Scalars["Time"]>;
  startGT?: InputMaybe<Scalars["Time"]>;
  startGTE?: InputMaybe<Scalars["Time"]>;
  startIn?: InputMaybe<Array<Scalars["Time"]>>;
  startLT?: InputMaybe<Scalars["Time"]>;
  startLTE?: InputMaybe<Scalars["Time"]>;
  startNEQ?: InputMaybe<Scalars["Time"]>;
  startNotIn?: InputMaybe<Array<Scalars["Time"]>>;
  /** type field predicates */
  type?: InputMaybe<ProductSaleType>;
  typeIn?: InputMaybe<Array<ProductSaleType>>;
  /** type_info field predicates */
  typeInfo?: InputMaybe<Scalars["String"]>;
  typeInfoContains?: InputMaybe<Scalars["String"]>;
  typeInfoContainsFold?: InputMaybe<Scalars["String"]>;
  typeInfoEqualFold?: InputMaybe<Scalars["String"]>;
  typeInfoGT?: InputMaybe<Scalars["String"]>;
  typeInfoGTE?: InputMaybe<Scalars["String"]>;
  typeInfoHasPrefix?: InputMaybe<Scalars["String"]>;
  typeInfoHasSuffix?: InputMaybe<Scalars["String"]>;
  typeInfoIn?: InputMaybe<Array<Scalars["String"]>>;
  typeInfoIsNil?: InputMaybe<Scalars["Boolean"]>;
  typeInfoLT?: InputMaybe<Scalars["String"]>;
  typeInfoLTE?: InputMaybe<Scalars["String"]>;
  typeInfoNEQ?: InputMaybe<Scalars["String"]>;
  typeInfoNotIn?: InputMaybe<Array<Scalars["String"]>>;
  typeInfoNotNil?: InputMaybe<Scalars["Boolean"]>;
  typeNEQ?: InputMaybe<ProductSaleType>;
  typeNotIn?: InputMaybe<Array<ProductSaleType>>;
  /** unit_size field predicates */
  unitSize?: InputMaybe<Scalars["Decimal"]>;
  unitSizeGT?: InputMaybe<Scalars["Decimal"]>;
  unitSizeGTE?: InputMaybe<Scalars["Decimal"]>;
  unitSizeIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  unitSizeLT?: InputMaybe<Scalars["Decimal"]>;
  unitSizeLTE?: InputMaybe<Scalars["Decimal"]>;
  unitSizeNEQ?: InputMaybe<Scalars["Decimal"]>;
  unitSizeNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** unit_type field predicates */
  unitType?: InputMaybe<ProductSaleUnitType>;
  unitTypeIn?: InputMaybe<Array<ProductSaleUnitType>>;
  unitTypeNEQ?: InputMaybe<ProductSaleUnitType>;
  unitTypeNotIn?: InputMaybe<Array<ProductSaleUnitType>>;
}

/** ProductStore is enum for the field store */
export enum ProductStore {
  ah = "ah",
  aldi = "aldi",
  dirk = "dirk",
}

/** ProductUnitType is enum for the field unit_type */
export enum ProductUnitType {
  g = "g",
  kg = "kg",
  l = "l",
  ml = "ml",
  none = "none",
  pak = "pak",
  per = "per",
  pods = "pods",
  stuk = "stuk",
  stuks = "stuks",
  zakjes = "zakjes",
}

/**
 * ProductWhereInput is used for filtering Product objects.
 * Input was generated by ent.
 */
export interface ProductWhereInput {
  and?: InputMaybe<Array<ProductWhereInput>>;
  /** brand field predicates */
  brand?: InputMaybe<Scalars["String"]>;
  brandContains?: InputMaybe<Scalars["String"]>;
  brandContainsFold?: InputMaybe<Scalars["String"]>;
  brandEqualFold?: InputMaybe<Scalars["String"]>;
  brandGT?: InputMaybe<Scalars["String"]>;
  brandGTE?: InputMaybe<Scalars["String"]>;
  brandHasPrefix?: InputMaybe<Scalars["String"]>;
  brandHasSuffix?: InputMaybe<Scalars["String"]>;
  brandIn?: InputMaybe<Array<Scalars["String"]>>;
  brandLT?: InputMaybe<Scalars["String"]>;
  brandLTE?: InputMaybe<Scalars["String"]>;
  brandNEQ?: InputMaybe<Scalars["String"]>;
  brandNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** category field predicates */
  category?: InputMaybe<Scalars["String"]>;
  categoryContains?: InputMaybe<Scalars["String"]>;
  categoryContainsFold?: InputMaybe<Scalars["String"]>;
  categoryEqualFold?: InputMaybe<Scalars["String"]>;
  categoryGT?: InputMaybe<Scalars["String"]>;
  categoryGTE?: InputMaybe<Scalars["String"]>;
  categoryHasPrefix?: InputMaybe<Scalars["String"]>;
  categoryHasSuffix?: InputMaybe<Scalars["String"]>;
  categoryIn?: InputMaybe<Array<Scalars["String"]>>;
  categoryLT?: InputMaybe<Scalars["String"]>;
  categoryLTE?: InputMaybe<Scalars["String"]>;
  categoryNEQ?: InputMaybe<Scalars["String"]>;
  categoryNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** default_unit_type field predicates */
  defaultUnitType?: InputMaybe<ProductDefaultUnitType>;
  defaultUnitTypeIn?: InputMaybe<Array<ProductDefaultUnitType>>;
  defaultUnitTypeNEQ?: InputMaybe<ProductDefaultUnitType>;
  defaultUnitTypeNotIn?: InputMaybe<Array<ProductDefaultUnitType>>;
  /** default_unit_type_price field predicates */
  defaultUnitTypePrice?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceGT?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceGTE?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  defaultUnitTypePriceLT?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceLTE?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceNEQ?: InputMaybe<Scalars["Decimal"]>;
  defaultUnitTypePriceNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** description field predicates */
  description?: InputMaybe<Scalars["String"]>;
  descriptionContains?: InputMaybe<Scalars["String"]>;
  descriptionContainsFold?: InputMaybe<Scalars["String"]>;
  descriptionEqualFold?: InputMaybe<Scalars["String"]>;
  descriptionGT?: InputMaybe<Scalars["String"]>;
  descriptionGTE?: InputMaybe<Scalars["String"]>;
  descriptionHasPrefix?: InputMaybe<Scalars["String"]>;
  descriptionHasSuffix?: InputMaybe<Scalars["String"]>;
  descriptionIn?: InputMaybe<Array<Scalars["String"]>>;
  descriptionIsNil?: InputMaybe<Scalars["Boolean"]>;
  descriptionLT?: InputMaybe<Scalars["String"]>;
  descriptionLTE?: InputMaybe<Scalars["String"]>;
  descriptionNEQ?: InputMaybe<Scalars["String"]>;
  descriptionNotIn?: InputMaybe<Array<Scalars["String"]>>;
  descriptionNotNil?: InputMaybe<Scalars["Boolean"]>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars["String"]>;
  externalIDContains?: InputMaybe<Scalars["String"]>;
  externalIDContainsFold?: InputMaybe<Scalars["String"]>;
  externalIDEqualFold?: InputMaybe<Scalars["String"]>;
  externalIDGT?: InputMaybe<Scalars["String"]>;
  externalIDGTE?: InputMaybe<Scalars["String"]>;
  externalIDHasPrefix?: InputMaybe<Scalars["String"]>;
  externalIDHasSuffix?: InputMaybe<Scalars["String"]>;
  externalIDIn?: InputMaybe<Array<Scalars["String"]>>;
  externalIDLT?: InputMaybe<Scalars["String"]>;
  externalIDLTE?: InputMaybe<Scalars["String"]>;
  externalIDNEQ?: InputMaybe<Scalars["String"]>;
  externalIDNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** actions edge predicates */
  hasActions?: InputMaybe<Scalars["Boolean"]>;
  hasActionsWith?: InputMaybe<Array<ProductActionWhereInput>>;
  /** sales edge predicates */
  hasSales?: InputMaybe<Scalars["Boolean"]>;
  hasSalesWith?: InputMaybe<Array<ProductSaleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** image field predicates */
  image?: InputMaybe<Scalars["String"]>;
  imageContains?: InputMaybe<Scalars["String"]>;
  imageContainsFold?: InputMaybe<Scalars["String"]>;
  imageEqualFold?: InputMaybe<Scalars["String"]>;
  imageGT?: InputMaybe<Scalars["String"]>;
  imageGTE?: InputMaybe<Scalars["String"]>;
  imageHasPrefix?: InputMaybe<Scalars["String"]>;
  imageHasSuffix?: InputMaybe<Scalars["String"]>;
  imageIn?: InputMaybe<Array<Scalars["String"]>>;
  imageLT?: InputMaybe<Scalars["String"]>;
  imageLTE?: InputMaybe<Scalars["String"]>;
  imageNEQ?: InputMaybe<Scalars["String"]>;
  imageNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<ProductWhereInput>;
  or?: InputMaybe<Array<ProductWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars["Decimal"]>;
  priceGT?: InputMaybe<Scalars["Decimal"]>;
  priceGTE?: InputMaybe<Scalars["Decimal"]>;
  priceIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  priceLT?: InputMaybe<Scalars["Decimal"]>;
  priceLTE?: InputMaybe<Scalars["Decimal"]>;
  priceNEQ?: InputMaybe<Scalars["Decimal"]>;
  priceNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** store field predicates */
  store?: InputMaybe<ProductStore>;
  storeIn?: InputMaybe<Array<ProductStore>>;
  storeNEQ?: InputMaybe<ProductStore>;
  storeNotIn?: InputMaybe<Array<ProductStore>>;
  /** subcategory field predicates */
  subcategory?: InputMaybe<Scalars["String"]>;
  subcategoryContains?: InputMaybe<Scalars["String"]>;
  subcategoryContainsFold?: InputMaybe<Scalars["String"]>;
  subcategoryEqualFold?: InputMaybe<Scalars["String"]>;
  subcategoryGT?: InputMaybe<Scalars["String"]>;
  subcategoryGTE?: InputMaybe<Scalars["String"]>;
  subcategoryHasPrefix?: InputMaybe<Scalars["String"]>;
  subcategoryHasSuffix?: InputMaybe<Scalars["String"]>;
  subcategoryIn?: InputMaybe<Array<Scalars["String"]>>;
  subcategoryLT?: InputMaybe<Scalars["String"]>;
  subcategoryLTE?: InputMaybe<Scalars["String"]>;
  subcategoryNEQ?: InputMaybe<Scalars["String"]>;
  subcategoryNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** unit_size field predicates */
  unitSize?: InputMaybe<Scalars["Decimal"]>;
  unitSizeGT?: InputMaybe<Scalars["Decimal"]>;
  unitSizeGTE?: InputMaybe<Scalars["Decimal"]>;
  unitSizeIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  unitSizeLT?: InputMaybe<Scalars["Decimal"]>;
  unitSizeLTE?: InputMaybe<Scalars["Decimal"]>;
  unitSizeNEQ?: InputMaybe<Scalars["Decimal"]>;
  unitSizeNotIn?: InputMaybe<Array<Scalars["Decimal"]>>;
  /** unit_type field predicates */
  unitType?: InputMaybe<ProductUnitType>;
  unitTypeIn?: InputMaybe<Array<ProductUnitType>>;
  unitTypeNEQ?: InputMaybe<ProductUnitType>;
  unitTypeNotIn?: InputMaybe<Array<ProductUnitType>>;
  /** url field predicates */
  url?: InputMaybe<Scalars["String"]>;
  urlContains?: InputMaybe<Scalars["String"]>;
  urlContainsFold?: InputMaybe<Scalars["String"]>;
  urlEqualFold?: InputMaybe<Scalars["String"]>;
  urlGT?: InputMaybe<Scalars["String"]>;
  urlGTE?: InputMaybe<Scalars["String"]>;
  urlHasPrefix?: InputMaybe<Scalars["String"]>;
  urlHasSuffix?: InputMaybe<Scalars["String"]>;
  urlIn?: InputMaybe<Array<Scalars["String"]>>;
  urlLT?: InputMaybe<Scalars["String"]>;
  urlLTE?: InputMaybe<Scalars["String"]>;
  urlNEQ?: InputMaybe<Scalars["String"]>;
  urlNotIn?: InputMaybe<Array<Scalars["String"]>>;
}

/**
 * RecipeAuthorWhereInput is used for filtering RecipeAuthor objects.
 * Input was generated by ent.
 */
export interface RecipeAuthorWhereInput {
  and?: InputMaybe<Array<RecipeAuthorWhereInput>>;
  /** recipe edge predicates */
  hasRecipe?: InputMaybe<Scalars["Boolean"]>;
  hasRecipeWith?: InputMaybe<Array<RecipeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<RecipeAuthorWhereInput>;
  or?: InputMaybe<Array<RecipeAuthorWhereInput>>;
}

/**
 * RecipeIngredientWhereInput is used for filtering RecipeIngredient objects.
 * Input was generated by ent.
 */
export interface RecipeIngredientWhereInput {
  and?: InputMaybe<Array<RecipeIngredientWhereInput>>;
  /** recipe edge predicates */
  hasRecipe?: InputMaybe<Scalars["Boolean"]>;
  hasRecipeWith?: InputMaybe<Array<RecipeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<RecipeIngredientWhereInput>;
  or?: InputMaybe<Array<RecipeIngredientWhereInput>>;
}

/**
 * RecipeInstructionWhereInput is used for filtering RecipeInstruction objects.
 * Input was generated by ent.
 */
export interface RecipeInstructionWhereInput {
  and?: InputMaybe<Array<RecipeInstructionWhereInput>>;
  /** recipe edge predicates */
  hasRecipe?: InputMaybe<Scalars["Boolean"]>;
  hasRecipeWith?: InputMaybe<Array<RecipeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** instruction field predicates */
  instruction?: InputMaybe<Scalars["String"]>;
  instructionContains?: InputMaybe<Scalars["String"]>;
  instructionContainsFold?: InputMaybe<Scalars["String"]>;
  instructionEqualFold?: InputMaybe<Scalars["String"]>;
  instructionGT?: InputMaybe<Scalars["String"]>;
  instructionGTE?: InputMaybe<Scalars["String"]>;
  instructionHasPrefix?: InputMaybe<Scalars["String"]>;
  instructionHasSuffix?: InputMaybe<Scalars["String"]>;
  instructionIn?: InputMaybe<Array<Scalars["String"]>>;
  instructionLT?: InputMaybe<Scalars["String"]>;
  instructionLTE?: InputMaybe<Scalars["String"]>;
  instructionNEQ?: InputMaybe<Scalars["String"]>;
  instructionNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<RecipeInstructionWhereInput>;
  or?: InputMaybe<Array<RecipeInstructionWhereInput>>;
}

/**
 * RecipeWhereInput is used for filtering Recipe objects.
 * Input was generated by ent.
 */
export interface RecipeWhereInput {
  and?: InputMaybe<Array<RecipeWhereInput>>;
  /** cook_time field predicates */
  cookTime?: InputMaybe<Scalars["Int"]>;
  cookTimeGT?: InputMaybe<Scalars["Int"]>;
  cookTimeGTE?: InputMaybe<Scalars["Int"]>;
  cookTimeIn?: InputMaybe<Array<Scalars["Int"]>>;
  cookTimeLT?: InputMaybe<Scalars["Int"]>;
  cookTimeLTE?: InputMaybe<Scalars["Int"]>;
  cookTimeNEQ?: InputMaybe<Scalars["Int"]>;
  cookTimeNotIn?: InputMaybe<Array<Scalars["Int"]>>;
  /** description field predicates */
  description?: InputMaybe<Scalars["String"]>;
  descriptionContains?: InputMaybe<Scalars["String"]>;
  descriptionContainsFold?: InputMaybe<Scalars["String"]>;
  descriptionEqualFold?: InputMaybe<Scalars["String"]>;
  descriptionGT?: InputMaybe<Scalars["String"]>;
  descriptionGTE?: InputMaybe<Scalars["String"]>;
  descriptionHasPrefix?: InputMaybe<Scalars["String"]>;
  descriptionHasSuffix?: InputMaybe<Scalars["String"]>;
  descriptionIn?: InputMaybe<Array<Scalars["String"]>>;
  descriptionLT?: InputMaybe<Scalars["String"]>;
  descriptionLTE?: InputMaybe<Scalars["String"]>;
  descriptionNEQ?: InputMaybe<Scalars["String"]>;
  descriptionNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars["Boolean"]>;
  hasAuthorWith?: InputMaybe<Array<RecipeAuthorWhereInput>>;
  /** ingredients edge predicates */
  hasIngredients?: InputMaybe<Scalars["Boolean"]>;
  hasIngredientsWith?: InputMaybe<Array<RecipeIngredientWhereInput>>;
  /** instructions edge predicates */
  hasInstructions?: InputMaybe<Scalars["Boolean"]>;
  hasInstructionsWith?: InputMaybe<Array<RecipeInstructionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<RecipeWhereInput>;
  or?: InputMaybe<Array<RecipeWhereInput>>;
  /** prep_time field predicates */
  prepTime?: InputMaybe<Scalars["Int"]>;
  prepTimeGT?: InputMaybe<Scalars["Int"]>;
  prepTimeGTE?: InputMaybe<Scalars["Int"]>;
  prepTimeIn?: InputMaybe<Array<Scalars["Int"]>>;
  prepTimeLT?: InputMaybe<Scalars["Int"]>;
  prepTimeLTE?: InputMaybe<Scalars["Int"]>;
  prepTimeNEQ?: InputMaybe<Scalars["Int"]>;
  prepTimeNotIn?: InputMaybe<Array<Scalars["Int"]>>;
  /** yield field predicates */
  yield?: InputMaybe<Scalars["Int"]>;
  yieldGT?: InputMaybe<Scalars["Int"]>;
  yieldGTE?: InputMaybe<Scalars["Int"]>;
  yieldIn?: InputMaybe<Array<Scalars["Int"]>>;
  yieldLT?: InputMaybe<Scalars["Int"]>;
  yieldLTE?: InputMaybe<Scalars["Int"]>;
  yieldNEQ?: InputMaybe<Scalars["Int"]>;
  yieldNotIn?: InputMaybe<Array<Scalars["Int"]>>;
  /** yield_unit field predicates */
  yieldUnit?: InputMaybe<RecipeYieldUnit>;
  yieldUnitIn?: InputMaybe<Array<RecipeYieldUnit>>;
  yieldUnitNEQ?: InputMaybe<RecipeYieldUnit>;
  yieldUnitNotIn?: InputMaybe<Array<RecipeYieldUnit>>;
}

/** RecipeYieldUnit is enum for the field yield_unit */
export enum RecipeYieldUnit {
  batch = "batch",
  person = "person",
  serving = "serving",
}

/**
 * UpdateRecipeInput is used for update Recipe object.
 * Input was generated by ent.
 */
export interface UpdateRecipeInput {
  addAuthorIDs?: InputMaybe<Array<Scalars["ID"]>>;
  addIngredientIDs?: InputMaybe<Array<Scalars["ID"]>>;
  addInstructionIDs?: InputMaybe<Array<Scalars["ID"]>>;
  clearAuthor?: InputMaybe<Scalars["Boolean"]>;
  clearIngredients?: InputMaybe<Scalars["Boolean"]>;
  clearInstructions?: InputMaybe<Scalars["Boolean"]>;
  cookTime?: InputMaybe<Scalars["Int"]>;
  description?: InputMaybe<Scalars["String"]>;
  name?: InputMaybe<Scalars["String"]>;
  prepTime?: InputMaybe<Scalars["Int"]>;
  removeAuthorIDs?: InputMaybe<Array<Scalars["ID"]>>;
  removeIngredientIDs?: InputMaybe<Array<Scalars["ID"]>>;
  removeInstructionIDs?: InputMaybe<Array<Scalars["ID"]>>;
  yield?: InputMaybe<Scalars["Int"]>;
  yieldUnit?: InputMaybe<RecipeYieldUnit>;
}

export const scalarsEnumsHash: import("gqty").ScalarsEnumsHash = {
  Boolean: true,
  Cursor: true,
  Decimal: true,
  ID: true,
  Int: true,
  OrderDirection: true,
  ProductActionAction: true,
  ProductDefaultUnitType: true,
  ProductSaleDefaultUnitType: true,
  ProductSaleType: true,
  ProductSaleUnitType: true,
  ProductStore: true,
  ProductUnitType: true,
  RecipeYieldUnit: true,
  String: true,
  Time: true,
};
export const generatedSchema = {
  CreateRecipeAuthorInput: {
    name: { __type: "String!" },
    recipeIDs: { __type: "[ID!]" },
  },
  CreateRecipeIngredientInput: { recipeIDs: { __type: "[ID!]" } },
  CreateRecipeInput: {
    authorIDs: { __type: "[ID!]" },
    cookTime: { __type: "Int!" },
    description: { __type: "String!" },
    ingredientIDs: { __type: "[ID!]" },
    instructionIDs: { __type: "[ID!]" },
    name: { __type: "String!" },
    prepTime: { __type: "Int!" },
    yield: { __type: "Int!" },
    yieldUnit: { __type: "RecipeYieldUnit!" },
  },
  CreateRecipeInstructionInput: {
    instruction: { __type: "String!" },
    recipeID: { __type: "ID" },
  },
  Node: {
    __typename: { __type: "String!" },
    id: { __type: "ID!" },
    $on: { __type: "$Node!" },
  },
  PageInfo: {
    __typename: { __type: "String!" },
    endCursor: { __type: "Cursor" },
    hasNextPage: { __type: "Boolean!" },
    hasPreviousPage: { __type: "Boolean!" },
    startCursor: { __type: "Cursor" },
  },
  Product: {
    __typename: { __type: "String!" },
    actions: { __type: "ProductAction" },
    brand: { __type: "String!" },
    category: { __type: "String!" },
    defaultUnitType: { __type: "ProductDefaultUnitType!" },
    defaultUnitTypePrice: { __type: "Decimal!" },
    description: { __type: "String" },
    externalID: { __type: "String!" },
    id: { __type: "ID!" },
    image: { __type: "String!" },
    name: { __type: "String!" },
    price: { __type: "Decimal!" },
    sales: { __type: "ProductSale" },
    store: { __type: "ProductStore!" },
    subcategory: { __type: "String!" },
    unitSize: { __type: "Decimal!" },
    unitType: { __type: "ProductUnitType!" },
    url: { __type: "String!" },
  },
  ProductAction: {
    __typename: { __type: "String!" },
    action: { __type: "ProductActionAction!" },
    id: { __type: "ID!" },
    newPrice: { __type: "Decimal!" },
    products: { __type: "[Product!]" },
  },
  ProductActionWhereInput: {
    action: { __type: "ProductActionAction" },
    actionIn: { __type: "[ProductActionAction!]" },
    actionNEQ: { __type: "ProductActionAction" },
    actionNotIn: { __type: "[ProductActionAction!]" },
    and: { __type: "[ProductActionWhereInput!]" },
    hasProducts: { __type: "Boolean" },
    hasProductsWith: { __type: "[ProductWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    newPrice: { __type: "Decimal" },
    newPriceGT: { __type: "Decimal" },
    newPriceGTE: { __type: "Decimal" },
    newPriceIn: { __type: "[Decimal!]" },
    newPriceLT: { __type: "Decimal" },
    newPriceLTE: { __type: "Decimal" },
    newPriceNEQ: { __type: "Decimal" },
    newPriceNotIn: { __type: "[Decimal!]" },
    not: { __type: "ProductActionWhereInput" },
    or: { __type: "[ProductActionWhereInput!]" },
  },
  ProductSale: {
    __typename: { __type: "String!" },
    defaultUnitType: { __type: "ProductSaleDefaultUnitType!" },
    defaultUnitTypePrice: { __type: "Decimal!" },
    end: { __type: "Time!" },
    externalID: { __type: "String!" },
    id: { __type: "ID!" },
    price: { __type: "Decimal!" },
    products: { __type: "[Product!]" },
    start: { __type: "Time!" },
    type: { __type: "ProductSaleType!" },
    typeInfo: { __type: "String" },
    unitSize: { __type: "Decimal!" },
    unitType: { __type: "ProductSaleUnitType!" },
  },
  ProductSaleWhereInput: {
    and: { __type: "[ProductSaleWhereInput!]" },
    defaultUnitType: { __type: "ProductSaleDefaultUnitType" },
    defaultUnitTypeIn: { __type: "[ProductSaleDefaultUnitType!]" },
    defaultUnitTypeNEQ: { __type: "ProductSaleDefaultUnitType" },
    defaultUnitTypeNotIn: { __type: "[ProductSaleDefaultUnitType!]" },
    defaultUnitTypePrice: { __type: "Decimal" },
    defaultUnitTypePriceGT: { __type: "Decimal" },
    defaultUnitTypePriceGTE: { __type: "Decimal" },
    defaultUnitTypePriceIn: { __type: "[Decimal!]" },
    defaultUnitTypePriceLT: { __type: "Decimal" },
    defaultUnitTypePriceLTE: { __type: "Decimal" },
    defaultUnitTypePriceNEQ: { __type: "Decimal" },
    defaultUnitTypePriceNotIn: { __type: "[Decimal!]" },
    end: { __type: "Time" },
    endGT: { __type: "Time" },
    endGTE: { __type: "Time" },
    endIn: { __type: "[Time!]" },
    endLT: { __type: "Time" },
    endLTE: { __type: "Time" },
    endNEQ: { __type: "Time" },
    endNotIn: { __type: "[Time!]" },
    externalID: { __type: "String" },
    externalIDContains: { __type: "String" },
    externalIDContainsFold: { __type: "String" },
    externalIDEqualFold: { __type: "String" },
    externalIDGT: { __type: "String" },
    externalIDGTE: { __type: "String" },
    externalIDHasPrefix: { __type: "String" },
    externalIDHasSuffix: { __type: "String" },
    externalIDIn: { __type: "[String!]" },
    externalIDLT: { __type: "String" },
    externalIDLTE: { __type: "String" },
    externalIDNEQ: { __type: "String" },
    externalIDNotIn: { __type: "[String!]" },
    hasProducts: { __type: "Boolean" },
    hasProductsWith: { __type: "[ProductWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    not: { __type: "ProductSaleWhereInput" },
    or: { __type: "[ProductSaleWhereInput!]" },
    price: { __type: "Decimal" },
    priceGT: { __type: "Decimal" },
    priceGTE: { __type: "Decimal" },
    priceIn: { __type: "[Decimal!]" },
    priceLT: { __type: "Decimal" },
    priceLTE: { __type: "Decimal" },
    priceNEQ: { __type: "Decimal" },
    priceNotIn: { __type: "[Decimal!]" },
    start: { __type: "Time" },
    startGT: { __type: "Time" },
    startGTE: { __type: "Time" },
    startIn: { __type: "[Time!]" },
    startLT: { __type: "Time" },
    startLTE: { __type: "Time" },
    startNEQ: { __type: "Time" },
    startNotIn: { __type: "[Time!]" },
    type: { __type: "ProductSaleType" },
    typeIn: { __type: "[ProductSaleType!]" },
    typeInfo: { __type: "String" },
    typeInfoContains: { __type: "String" },
    typeInfoContainsFold: { __type: "String" },
    typeInfoEqualFold: { __type: "String" },
    typeInfoGT: { __type: "String" },
    typeInfoGTE: { __type: "String" },
    typeInfoHasPrefix: { __type: "String" },
    typeInfoHasSuffix: { __type: "String" },
    typeInfoIn: { __type: "[String!]" },
    typeInfoIsNil: { __type: "Boolean" },
    typeInfoLT: { __type: "String" },
    typeInfoLTE: { __type: "String" },
    typeInfoNEQ: { __type: "String" },
    typeInfoNotIn: { __type: "[String!]" },
    typeInfoNotNil: { __type: "Boolean" },
    typeNEQ: { __type: "ProductSaleType" },
    typeNotIn: { __type: "[ProductSaleType!]" },
    unitSize: { __type: "Decimal" },
    unitSizeGT: { __type: "Decimal" },
    unitSizeGTE: { __type: "Decimal" },
    unitSizeIn: { __type: "[Decimal!]" },
    unitSizeLT: { __type: "Decimal" },
    unitSizeLTE: { __type: "Decimal" },
    unitSizeNEQ: { __type: "Decimal" },
    unitSizeNotIn: { __type: "[Decimal!]" },
    unitType: { __type: "ProductSaleUnitType" },
    unitTypeIn: { __type: "[ProductSaleUnitType!]" },
    unitTypeNEQ: { __type: "ProductSaleUnitType" },
    unitTypeNotIn: { __type: "[ProductSaleUnitType!]" },
  },
  ProductWhereInput: {
    and: { __type: "[ProductWhereInput!]" },
    brand: { __type: "String" },
    brandContains: { __type: "String" },
    brandContainsFold: { __type: "String" },
    brandEqualFold: { __type: "String" },
    brandGT: { __type: "String" },
    brandGTE: { __type: "String" },
    brandHasPrefix: { __type: "String" },
    brandHasSuffix: { __type: "String" },
    brandIn: { __type: "[String!]" },
    brandLT: { __type: "String" },
    brandLTE: { __type: "String" },
    brandNEQ: { __type: "String" },
    brandNotIn: { __type: "[String!]" },
    category: { __type: "String" },
    categoryContains: { __type: "String" },
    categoryContainsFold: { __type: "String" },
    categoryEqualFold: { __type: "String" },
    categoryGT: { __type: "String" },
    categoryGTE: { __type: "String" },
    categoryHasPrefix: { __type: "String" },
    categoryHasSuffix: { __type: "String" },
    categoryIn: { __type: "[String!]" },
    categoryLT: { __type: "String" },
    categoryLTE: { __type: "String" },
    categoryNEQ: { __type: "String" },
    categoryNotIn: { __type: "[String!]" },
    defaultUnitType: { __type: "ProductDefaultUnitType" },
    defaultUnitTypeIn: { __type: "[ProductDefaultUnitType!]" },
    defaultUnitTypeNEQ: { __type: "ProductDefaultUnitType" },
    defaultUnitTypeNotIn: { __type: "[ProductDefaultUnitType!]" },
    defaultUnitTypePrice: { __type: "Decimal" },
    defaultUnitTypePriceGT: { __type: "Decimal" },
    defaultUnitTypePriceGTE: { __type: "Decimal" },
    defaultUnitTypePriceIn: { __type: "[Decimal!]" },
    defaultUnitTypePriceLT: { __type: "Decimal" },
    defaultUnitTypePriceLTE: { __type: "Decimal" },
    defaultUnitTypePriceNEQ: { __type: "Decimal" },
    defaultUnitTypePriceNotIn: { __type: "[Decimal!]" },
    description: { __type: "String" },
    descriptionContains: { __type: "String" },
    descriptionContainsFold: { __type: "String" },
    descriptionEqualFold: { __type: "String" },
    descriptionGT: { __type: "String" },
    descriptionGTE: { __type: "String" },
    descriptionHasPrefix: { __type: "String" },
    descriptionHasSuffix: { __type: "String" },
    descriptionIn: { __type: "[String!]" },
    descriptionIsNil: { __type: "Boolean" },
    descriptionLT: { __type: "String" },
    descriptionLTE: { __type: "String" },
    descriptionNEQ: { __type: "String" },
    descriptionNotIn: { __type: "[String!]" },
    descriptionNotNil: { __type: "Boolean" },
    externalID: { __type: "String" },
    externalIDContains: { __type: "String" },
    externalIDContainsFold: { __type: "String" },
    externalIDEqualFold: { __type: "String" },
    externalIDGT: { __type: "String" },
    externalIDGTE: { __type: "String" },
    externalIDHasPrefix: { __type: "String" },
    externalIDHasSuffix: { __type: "String" },
    externalIDIn: { __type: "[String!]" },
    externalIDLT: { __type: "String" },
    externalIDLTE: { __type: "String" },
    externalIDNEQ: { __type: "String" },
    externalIDNotIn: { __type: "[String!]" },
    hasActions: { __type: "Boolean" },
    hasActionsWith: { __type: "[ProductActionWhereInput!]" },
    hasSales: { __type: "Boolean" },
    hasSalesWith: { __type: "[ProductSaleWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    image: { __type: "String" },
    imageContains: { __type: "String" },
    imageContainsFold: { __type: "String" },
    imageEqualFold: { __type: "String" },
    imageGT: { __type: "String" },
    imageGTE: { __type: "String" },
    imageHasPrefix: { __type: "String" },
    imageHasSuffix: { __type: "String" },
    imageIn: { __type: "[String!]" },
    imageLT: { __type: "String" },
    imageLTE: { __type: "String" },
    imageNEQ: { __type: "String" },
    imageNotIn: { __type: "[String!]" },
    name: { __type: "String" },
    nameContains: { __type: "String" },
    nameContainsFold: { __type: "String" },
    nameEqualFold: { __type: "String" },
    nameGT: { __type: "String" },
    nameGTE: { __type: "String" },
    nameHasPrefix: { __type: "String" },
    nameHasSuffix: { __type: "String" },
    nameIn: { __type: "[String!]" },
    nameLT: { __type: "String" },
    nameLTE: { __type: "String" },
    nameNEQ: { __type: "String" },
    nameNotIn: { __type: "[String!]" },
    not: { __type: "ProductWhereInput" },
    or: { __type: "[ProductWhereInput!]" },
    price: { __type: "Decimal" },
    priceGT: { __type: "Decimal" },
    priceGTE: { __type: "Decimal" },
    priceIn: { __type: "[Decimal!]" },
    priceLT: { __type: "Decimal" },
    priceLTE: { __type: "Decimal" },
    priceNEQ: { __type: "Decimal" },
    priceNotIn: { __type: "[Decimal!]" },
    store: { __type: "ProductStore" },
    storeIn: { __type: "[ProductStore!]" },
    storeNEQ: { __type: "ProductStore" },
    storeNotIn: { __type: "[ProductStore!]" },
    subcategory: { __type: "String" },
    subcategoryContains: { __type: "String" },
    subcategoryContainsFold: { __type: "String" },
    subcategoryEqualFold: { __type: "String" },
    subcategoryGT: { __type: "String" },
    subcategoryGTE: { __type: "String" },
    subcategoryHasPrefix: { __type: "String" },
    subcategoryHasSuffix: { __type: "String" },
    subcategoryIn: { __type: "[String!]" },
    subcategoryLT: { __type: "String" },
    subcategoryLTE: { __type: "String" },
    subcategoryNEQ: { __type: "String" },
    subcategoryNotIn: { __type: "[String!]" },
    unitSize: { __type: "Decimal" },
    unitSizeGT: { __type: "Decimal" },
    unitSizeGTE: { __type: "Decimal" },
    unitSizeIn: { __type: "[Decimal!]" },
    unitSizeLT: { __type: "Decimal" },
    unitSizeLTE: { __type: "Decimal" },
    unitSizeNEQ: { __type: "Decimal" },
    unitSizeNotIn: { __type: "[Decimal!]" },
    unitType: { __type: "ProductUnitType" },
    unitTypeIn: { __type: "[ProductUnitType!]" },
    unitTypeNEQ: { __type: "ProductUnitType" },
    unitTypeNotIn: { __type: "[ProductUnitType!]" },
    url: { __type: "String" },
    urlContains: { __type: "String" },
    urlContainsFold: { __type: "String" },
    urlEqualFold: { __type: "String" },
    urlGT: { __type: "String" },
    urlGTE: { __type: "String" },
    urlHasPrefix: { __type: "String" },
    urlHasSuffix: { __type: "String" },
    urlIn: { __type: "[String!]" },
    urlLT: { __type: "String" },
    urlLTE: { __type: "String" },
    urlNEQ: { __type: "String" },
    urlNotIn: { __type: "[String!]" },
  },
  Recipe: {
    __typename: { __type: "String!" },
    author: { __type: "[RecipeAuthor!]" },
    cookTime: { __type: "Int!" },
    description: { __type: "String!" },
    id: { __type: "ID!" },
    ingredients: { __type: "[RecipeIngredient!]" },
    instructions: { __type: "[RecipeInstruction!]" },
    name: { __type: "String!" },
    prepTime: { __type: "Int!" },
    yield: { __type: "Int!" },
    yieldUnit: { __type: "RecipeYieldUnit!" },
  },
  RecipeAuthor: {
    __typename: { __type: "String!" },
    id: { __type: "ID!" },
    name: { __type: "String!" },
    recipe: { __type: "[Recipe!]" },
  },
  RecipeAuthorWhereInput: {
    and: { __type: "[RecipeAuthorWhereInput!]" },
    hasRecipe: { __type: "Boolean" },
    hasRecipeWith: { __type: "[RecipeWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    name: { __type: "String" },
    nameContains: { __type: "String" },
    nameContainsFold: { __type: "String" },
    nameEqualFold: { __type: "String" },
    nameGT: { __type: "String" },
    nameGTE: { __type: "String" },
    nameHasPrefix: { __type: "String" },
    nameHasSuffix: { __type: "String" },
    nameIn: { __type: "[String!]" },
    nameLT: { __type: "String" },
    nameLTE: { __type: "String" },
    nameNEQ: { __type: "String" },
    nameNotIn: { __type: "[String!]" },
    not: { __type: "RecipeAuthorWhereInput" },
    or: { __type: "[RecipeAuthorWhereInput!]" },
  },
  RecipeIngredient: {
    __typename: { __type: "String!" },
    id: { __type: "ID!" },
    recipe: { __type: "[Recipe!]" },
  },
  RecipeIngredientWhereInput: {
    and: { __type: "[RecipeIngredientWhereInput!]" },
    hasRecipe: { __type: "Boolean" },
    hasRecipeWith: { __type: "[RecipeWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    not: { __type: "RecipeIngredientWhereInput" },
    or: { __type: "[RecipeIngredientWhereInput!]" },
  },
  RecipeInstruction: {
    __typename: { __type: "String!" },
    id: { __type: "ID!" },
    instruction: { __type: "String!" },
    recipe: { __type: "Recipe" },
  },
  RecipeInstructionWhereInput: {
    and: { __type: "[RecipeInstructionWhereInput!]" },
    hasRecipe: { __type: "Boolean" },
    hasRecipeWith: { __type: "[RecipeWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    instruction: { __type: "String" },
    instructionContains: { __type: "String" },
    instructionContainsFold: { __type: "String" },
    instructionEqualFold: { __type: "String" },
    instructionGT: { __type: "String" },
    instructionGTE: { __type: "String" },
    instructionHasPrefix: { __type: "String" },
    instructionHasSuffix: { __type: "String" },
    instructionIn: { __type: "[String!]" },
    instructionLT: { __type: "String" },
    instructionLTE: { __type: "String" },
    instructionNEQ: { __type: "String" },
    instructionNotIn: { __type: "[String!]" },
    not: { __type: "RecipeInstructionWhereInput" },
    or: { __type: "[RecipeInstructionWhereInput!]" },
  },
  RecipeWhereInput: {
    and: { __type: "[RecipeWhereInput!]" },
    cookTime: { __type: "Int" },
    cookTimeGT: { __type: "Int" },
    cookTimeGTE: { __type: "Int" },
    cookTimeIn: { __type: "[Int!]" },
    cookTimeLT: { __type: "Int" },
    cookTimeLTE: { __type: "Int" },
    cookTimeNEQ: { __type: "Int" },
    cookTimeNotIn: { __type: "[Int!]" },
    description: { __type: "String" },
    descriptionContains: { __type: "String" },
    descriptionContainsFold: { __type: "String" },
    descriptionEqualFold: { __type: "String" },
    descriptionGT: { __type: "String" },
    descriptionGTE: { __type: "String" },
    descriptionHasPrefix: { __type: "String" },
    descriptionHasSuffix: { __type: "String" },
    descriptionIn: { __type: "[String!]" },
    descriptionLT: { __type: "String" },
    descriptionLTE: { __type: "String" },
    descriptionNEQ: { __type: "String" },
    descriptionNotIn: { __type: "[String!]" },
    hasAuthor: { __type: "Boolean" },
    hasAuthorWith: { __type: "[RecipeAuthorWhereInput!]" },
    hasIngredients: { __type: "Boolean" },
    hasIngredientsWith: { __type: "[RecipeIngredientWhereInput!]" },
    hasInstructions: { __type: "Boolean" },
    hasInstructionsWith: { __type: "[RecipeInstructionWhereInput!]" },
    id: { __type: "ID" },
    idGT: { __type: "ID" },
    idGTE: { __type: "ID" },
    idIn: { __type: "[ID!]" },
    idLT: { __type: "ID" },
    idLTE: { __type: "ID" },
    idNEQ: { __type: "ID" },
    idNotIn: { __type: "[ID!]" },
    name: { __type: "String" },
    nameContains: { __type: "String" },
    nameContainsFold: { __type: "String" },
    nameEqualFold: { __type: "String" },
    nameGT: { __type: "String" },
    nameGTE: { __type: "String" },
    nameHasPrefix: { __type: "String" },
    nameHasSuffix: { __type: "String" },
    nameIn: { __type: "[String!]" },
    nameLT: { __type: "String" },
    nameLTE: { __type: "String" },
    nameNEQ: { __type: "String" },
    nameNotIn: { __type: "[String!]" },
    not: { __type: "RecipeWhereInput" },
    or: { __type: "[RecipeWhereInput!]" },
    prepTime: { __type: "Int" },
    prepTimeGT: { __type: "Int" },
    prepTimeGTE: { __type: "Int" },
    prepTimeIn: { __type: "[Int!]" },
    prepTimeLT: { __type: "Int" },
    prepTimeLTE: { __type: "Int" },
    prepTimeNEQ: { __type: "Int" },
    prepTimeNotIn: { __type: "[Int!]" },
    yield: { __type: "Int" },
    yieldGT: { __type: "Int" },
    yieldGTE: { __type: "Int" },
    yieldIn: { __type: "[Int!]" },
    yieldLT: { __type: "Int" },
    yieldLTE: { __type: "Int" },
    yieldNEQ: { __type: "Int" },
    yieldNotIn: { __type: "[Int!]" },
    yieldUnit: { __type: "RecipeYieldUnit" },
    yieldUnitIn: { __type: "[RecipeYieldUnit!]" },
    yieldUnitNEQ: { __type: "RecipeYieldUnit" },
    yieldUnitNotIn: { __type: "[RecipeYieldUnit!]" },
  },
  UpdateRecipeInput: {
    addAuthorIDs: { __type: "[ID!]" },
    addIngredientIDs: { __type: "[ID!]" },
    addInstructionIDs: { __type: "[ID!]" },
    clearAuthor: { __type: "Boolean" },
    clearIngredients: { __type: "Boolean" },
    clearInstructions: { __type: "Boolean" },
    cookTime: { __type: "Int" },
    description: { __type: "String" },
    name: { __type: "String" },
    prepTime: { __type: "Int" },
    removeAuthorIDs: { __type: "[ID!]" },
    removeIngredientIDs: { __type: "[ID!]" },
    removeInstructionIDs: { __type: "[ID!]" },
    yield: { __type: "Int" },
    yieldUnit: { __type: "RecipeYieldUnit" },
  },
  mutation: {},
  query: {
    __typename: { __type: "String!" },
    node: { __type: "Node", __args: { id: "ID!" } },
    nodes: { __type: "[Node]!", __args: { ids: "[ID!]!" } },
    productActions: { __type: "[ProductAction!]!" },
    productSales: { __type: "[ProductSale!]!" },
    products: { __type: "[Product!]!" },
    recipeAuthors: { __type: "[RecipeAuthor!]!" },
    recipeIngredients: { __type: "[RecipeIngredient!]!" },
    recipeInstructions: { __type: "[RecipeInstruction!]!" },
    recipes: { __type: "[Recipe!]!" },
    search: { __type: "[Product!]", __args: { search: "String" } },
  },
  subscription: {},
  [SchemaUnionsKey]: {
    Node: [
      "Product",
      "ProductAction",
      "ProductSale",
      "Recipe",
      "RecipeAuthor",
      "RecipeIngredient",
      "RecipeInstruction",
    ],
  },
} as const;

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export interface Node {
  __typename?:
    | "Product"
    | "ProductAction"
    | "ProductSale"
    | "Recipe"
    | "RecipeAuthor"
    | "RecipeIngredient"
    | "RecipeInstruction";
  /**
   * The id of the object.
   */
  id: ScalarsEnums["ID"];
  $on: $Node;
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export interface PageInfo {
  __typename?: "PageInfo";
  /**
   * When paginating forwards, the cursor to continue.
   */
  endCursor?: Maybe<ScalarsEnums["Cursor"]>;
  /**
   * When paginating forwards, are there more items?
   */
  hasNextPage: ScalarsEnums["Boolean"];
  /**
   * When paginating backwards, are there more items?
   */
  hasPreviousPage: ScalarsEnums["Boolean"];
  /**
   * When paginating backwards, the cursor to continue.
   */
  startCursor?: Maybe<ScalarsEnums["Cursor"]>;
}

export interface Product {
  __typename?: "Product";
  actions?: Maybe<ProductAction>;
  brand: ScalarsEnums["String"];
  category: ScalarsEnums["String"];
  defaultUnitType: ScalarsEnums["ProductDefaultUnitType"];
  defaultUnitTypePrice: ScalarsEnums["Decimal"];
  description?: Maybe<ScalarsEnums["String"]>;
  externalID: ScalarsEnums["String"];
  id: ScalarsEnums["ID"];
  image: ScalarsEnums["String"];
  name: ScalarsEnums["String"];
  price: ScalarsEnums["Decimal"];
  sales?: Maybe<ProductSale>;
  store: ScalarsEnums["ProductStore"];
  subcategory: ScalarsEnums["String"];
  unitSize: ScalarsEnums["Decimal"];
  unitType: ScalarsEnums["ProductUnitType"];
  url: ScalarsEnums["String"];
}

export interface ProductAction {
  __typename?: "ProductAction";
  action: ScalarsEnums["ProductActionAction"];
  id: ScalarsEnums["ID"];
  newPrice: ScalarsEnums["Decimal"];
  products?: Maybe<Array<Product>>;
}

export interface ProductSale {
  __typename?: "ProductSale";
  defaultUnitType: ScalarsEnums["ProductSaleDefaultUnitType"];
  defaultUnitTypePrice: ScalarsEnums["Decimal"];
  end: ScalarsEnums["Time"];
  externalID: ScalarsEnums["String"];
  id: ScalarsEnums["ID"];
  price: ScalarsEnums["Decimal"];
  products?: Maybe<Array<Product>>;
  start: ScalarsEnums["Time"];
  type: ScalarsEnums["ProductSaleType"];
  typeInfo?: Maybe<ScalarsEnums["String"]>;
  unitSize: ScalarsEnums["Decimal"];
  unitType: ScalarsEnums["ProductSaleUnitType"];
}

export interface Recipe {
  __typename?: "Recipe";
  author?: Maybe<Array<RecipeAuthor>>;
  cookTime: ScalarsEnums["Int"];
  description: ScalarsEnums["String"];
  id: ScalarsEnums["ID"];
  ingredients?: Maybe<Array<RecipeIngredient>>;
  instructions?: Maybe<Array<RecipeInstruction>>;
  name: ScalarsEnums["String"];
  prepTime: ScalarsEnums["Int"];
  yield: ScalarsEnums["Int"];
  yieldUnit: ScalarsEnums["RecipeYieldUnit"];
}

export interface RecipeAuthor {
  __typename?: "RecipeAuthor";
  id: ScalarsEnums["ID"];
  name: ScalarsEnums["String"];
  recipe?: Maybe<Array<Recipe>>;
}

export interface RecipeIngredient {
  __typename?: "RecipeIngredient";
  id: ScalarsEnums["ID"];
  recipe?: Maybe<Array<Recipe>>;
}

export interface RecipeInstruction {
  __typename?: "RecipeInstruction";
  id: ScalarsEnums["ID"];
  instruction: ScalarsEnums["String"];
  recipe?: Maybe<Recipe>;
}

export interface Mutation {
  __typename?: "Mutation";
}

export interface Query {
  __typename?: "Query";
  /**
   * Fetches an object given its ID.
   */
  node: (args: {
    /**
     * ID of the object.
     */
    id: Scalars["ID"];
  }) => Maybe<Node>;
  /**
   * Lookup nodes by a list of IDs.
   */
  nodes: (args: {
    /**
     * The list of node IDs.
     */
    ids: Array<Scalars["ID"]>;
  }) => Array<Maybe<Node>>;
  productActions: Array<ProductAction>;
  productSales: Array<ProductSale>;
  products: Array<Product>;
  recipeAuthors: Array<RecipeAuthor>;
  recipeIngredients: Array<RecipeIngredient>;
  recipeInstructions: Array<RecipeInstruction>;
  recipes: Array<Recipe>;
  search: (args?: {
    search?: Maybe<Scalars["String"]>;
  }) => Maybe<Array<Product>>;
}

export interface Subscription {
  __typename?: "Subscription";
}

export interface $Node {
  Product?: Product;
  ProductAction?: ProductAction;
  ProductSale?: ProductSale;
  Recipe?: Recipe;
  RecipeAuthor?: RecipeAuthor;
  RecipeIngredient?: RecipeIngredient;
  RecipeInstruction?: RecipeInstruction;
}

export interface GeneratedSchema {
  query: Query;
  mutation: Mutation;
  subscription: Subscription;
}

export type MakeNullable<T> = {
  [K in keyof T]: T[K] | undefined;
};

export interface ScalarsEnums extends MakeNullable<Scalars> {
  OrderDirection: OrderDirection | undefined;
  ProductActionAction: ProductActionAction | undefined;
  ProductDefaultUnitType: ProductDefaultUnitType | undefined;
  ProductSaleDefaultUnitType: ProductSaleDefaultUnitType | undefined;
  ProductSaleType: ProductSaleType | undefined;
  ProductSaleUnitType: ProductSaleUnitType | undefined;
  ProductStore: ProductStore | undefined;
  ProductUnitType: ProductUnitType | undefined;
  RecipeYieldUnit: RecipeYieldUnit | undefined;
}
